/** @brief compared vectors from top and bottom of array and then
 * gradually compare inner vectors.
 * @param arr pointer to the array to be sorted
 * @param start index of the first element to be sorted
 * @param end index of the last element to be sorted
 * @param depth a parameter to follow the depth of recursion
 */
void laneCrossingCompareNew(float *arr, std::uint32_t firstIdx, std::uint32_t lastIdx,
                            std::uint32_t maxIdx, std::uint32_t depth) {
    if (firstIdx > maxIdx) {
        return;
    }
    std::uint32_t length = lastIdx - firstIdx + 1;
    if (length == 8) {
        int diff = lastIdx - firstIdx;
        if (diff < 1)
            return;
        __m256 reg;
        __m256i mask;
        if ((diff < 7))
            maskload(1 + diff, arr + firstIdx, mask, reg);
        else
            reg = _mm256_loadu_ps(arr + firstIdx);

        reverse_halves_and_compare(reg);
        shuffle_and_compare<0b01001110, 0b00110011>(reg);
        shuffle_and_compare<0b10110001, 0b01010101>(reg);
        if (diff < 7)
            _mm256_maskstore_ps(arr + firstIdx, mask, reg);
        else
            _mm256_storeu_ps(arr + firstIdx, reg);
        return;
    }

    float *p = arr + firstIdx;

    auto printVec = [](float *p, int length) {
        for (int i = 0; i < length; i++) {
            std::cout << *(p + i) << "  ";
        }
    };

    auto minMax = [&printVec](__m256 &reg0, __m256 &reg1) {
        __m256 min = _mm256_min_ps(reg1, reg0);
        reg1 = _mm256_max_ps(reg1, reg0);
        reg0 = min;
        /*std::cout << "minMax: " << std::endl;
        printVec((float *)(&reg0), 8);
        printVec((float *)(&reg1), 8);
        std::cout << std::endl;*/
    };

    std::cout << "\n\n\nFloat array: " << std::endl;
    printVec(p, length);
    std::cout << std::endl;
    // Divide length by 2 * simd size.
    std::uint32_t numVectorsToCompare = std::ceil(float(length) / float(16U));
    std::cout << "numVectorsToCompare = " << numVectorsToCompare << std::endl;
    std::cout << "length = " << length << std::endl;
    float *p1 = p;
    float *p2 = p + 8 * numVectorsToCompare;
    std::uint32_t i = 0;
    for (; i < numVectorsToCompare - 1; ++i) {
        // printVec(p1, 8);
        // printVec(p2, 8);
        __m256 reg1 = _mm256_loadu_ps(p1);
        __m256 reg2 = _mm256_loadu_ps(p2);
        minMax(reg1, reg2);
        _mm256_storeu_ps(p1, reg1);
        _mm256_storeu_ps(p2, reg2);
        // std::cout << std::endl;
        // printVec(p1, 8);
        // printVec(p2, 8);
        // std::cout << "\n" << std::endl;
        p1 += 8;
        p2 += 8;
    }
    // printVec(p1, 8);
    // printVec(p2, 8);
    // std::cout << "\n" << std::endl;
    std::uint32_t leftToLoad = length - 8 * numVectorsToCompare - i * 8;
    // std::cout << "leftToLoad = " << leftToLoad << std::endl;
    __m256 reg1 = _mm256_loadu_ps(p1);
    __m256i mask;
    __m256 reg2;
    maskload(leftToLoad, p2, mask, reg2);
    minMax(reg1, reg2);
    _mm256_storeu_ps(p1, reg1);
    _mm256_maskstore_ps(p2, mask, reg2);
    printVec(p1, 8);
    printVec(p2, 8);

    // std::cout << "\n\n";
    laneCrossingCompareNew(arr, firstIdx, (firstIdx + lastIdx) / 2, maxIdx, depth + 1);
    laneCrossingCompareNew(arr, (firstIdx + lastIdx) / 2 + 1, lastIdx, maxIdx, depth + 1);
};